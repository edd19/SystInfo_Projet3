\documentclass[10pt, a4paper, twocolumn]{article}

\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{multicol}
\usepackage{vmargin}
\usepackage{graphicx}
\usepackage{tabularx}



\setlength{\parindent}{0mm}


\renewcommand{\arraystretch}{2}


\begin{document}

% Page de titre
\titlepage{
	\today \\[7cm]
	\begin{flushright}\sf\Huge
	{\bfseries LSINF1252} \\[2mm]
	{\bfseries SYSTEMES INFORMATIQUES 1} \\[3mm]
	{\huge Rapport du Projet 3}
	\end{flushright}
	\ \\[8cm]
	
	Ndizera Eddy\\
	Solaiman El Jilali
}

\clearpage

\begin{multicols}{2}
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\quad Dans le cadre de ce projet, il nous a été demandé d'implémenter 2 benchmarks : un portant sur l'appel système readdir et un autre afin de comparer \textit{writev} avec \textit{lseek}+\textit{write}. Ce rapport contiendra des explications sur nos choix de scénarios et d'implémentation, une analyse des résultats de nos benchmarks avec graphe à l'appui ainsi que les difficultés rencontrées.


\section{Choix de scénarios et d'implémentation}

\subsection{\textit{writev}/\textit{lseek}+\textit{write}}

\quad Le scénario considéré pour ce benchmark s'est basé sur un critère: la taille du buffer (iov pour writev). La taille des buffer nous a été inspiré par le fait que \textit{writev} écrit par bloc (iovec) dont la longueur peut être fixé tandis que \textit{write} écrit par buffers dont la longueur aussi peut être fixée. Pour ce scénario, on compare le temps pris par \textit{writev} et \textit{lseek}+\textit{write} pour écrire un fichier d'une taille fixe mais pour des tailles de buffers différentes. D'autres scénarios ont été considérés comme le fait de d'utiliser 2 tailles de fichiers mais ils n'ont pas été repris du fait du peu d'informations qu'ils ajoutaient en plus. \\

\quad Pour l'implémentation du benchmark, nous avons écrit 2 méthodes \textit{benchmark\_writev} et \textit{benchmark\_lseek} qui prennent en argument un descripteur de fichier (fd), une taille du buffer/iov (buffer\_size), une taille de fichier à écrire (file\_size), un timer (t) et en dernier lieu un recorder (rec). Ces 2 méthodes, comme leur nom l'indiquent, sont utilisées pour calculer le temps que prend chaque appel système writev et lseek+write. \\

\quad \textit{benchmark\_writev} crée et initialise un tableau de iovec qui sont les blocs à écrire. Une fois l'initialisation terminée, il démarre le timer et fait appel à writev qui va se charger d'écrire les blocs dans un fichier. L'écriture étant terminée, il stoppe le timer et enregistre le temps  pris pour l'écriture d'un fichier.\\

\quad \textit{benchmark\_lseek} fonctionne de manière similaire sauf qu'il va démarrer le timer et entrer dans une boucle qui prendra fin quand il aura écrit une quantité de données égale à la taille du fichier à écrire. A l'intérieur de la boucle, la méthode écrit une chaîne de caractères dans un fichier via write puis repositionne le curseur du ficher à la fin de celui-ci. Lorsqu'on sort de la boucle, on arrête le timer et on enregistre le temps pris pour écrire un fichier. \\

\quad La fonction main se chargera simplement de faire appel à ces 2 méthodes en changeant leurs paramètres. Ce choix d'implémentation permet une modularité dans le sens où on peut facilement changer les tailles des buffer ou des fichiers à tester.\\

\quad Nous tenons également à souligner que la fonction \textit{lseek} n'est pas indispensable puisque write écrit à partir de la fin du fichier et donc, il n'est pas nécessaire de repositionner le curseur du fichier chaque fois à la fin.\\


\subsection{\textit{readdir}}
\quad Le scénario considéré pour pour ce benchmark se base sur le nombre de fichiers contenus dans le répertoire sur lequel l'appel système \textit{readdir} s'appliquera.

\quad En effet, intuitivement, nous pensions que le temps mis pour lister les fichiers contenu dans un dossier serait proportionnel au nombre de fichiers qu'il contient.
Pour vérifier cela, nous avons implémenté un benchmark générant un grand nombre de fichiers et lisant à intervalle régulier le répertoire.
Pour travailler proprement, une partie de la fonction main consiste à créer un sous-répertoire ./temp au répertoire courant et c'est dans ce répertoire que seront créés l'ensemble des fichiers. Soulignons que ce répertoire sera supprimé après l'application du benchmark afin de ne pas polluer inutilement le dossier de benchmark.

\quad Dans l'état actuel de notre benchmark, nous générons 10000 fichiers dans le dossier ./temp et tous les 100 fichiers (à partir du premier fichier), nous lançons \textit{benchmark\_readdir}. Lors de l'exécution de \textit{benchmark\_readdir}, nous démarrons un timer juste avant le parcourt complet du répertoire ./temp et l'arrêtons une fois que tous les fichiers de ce répertoire ont été lus. Dans la boucle parcourant ce répertoire nous incrémentons un compteur qui n'est effectivement pas compris dans l'appel système readdir. Cela dit, nous avons supposé cette incrémentation négligeable. De plus, cette opération s'effectue à chaque itération de la boucle. De ce fait, le "coût" de cette incrémentation est uniformément répartie sur chacune des lecture.

\quad D'autre part, le premier benchmark que nous avons élaboré se basait sur la taille des fichiers à parcourir par \textit{readdir}. Nous nous sommes rapidement rendu compte que l'appel système \textit{readdir} est indépendant de la taille des fichiers à parcourir. De ce fait, ce benchmark n'a pas été retenu. \\
\quad Subséquemment, étant donné qu'un répertoire est traité comme un fichier dont le contenu est la liste des fichiers référencés\footnote{Voir page 145 du syllabus SINF1252-Theorie}, il n'y a donc aucun intérêt à générer des répertoires à coté des fichiers générés. 

\section{Analyse des résultats}

\subsection{\textit{writev}/\textit{lseek}+\textit{write}}



\begin{figure*}
	\includegraphics[scale = 0.28]{writev.png}
	\includegraphics[scale = 0.28]{writev3.png}	
	\caption{Graphe du benchmark sur writev et lseek+write en fonction de la taille du buffer en byte et du temps.}
	\label{G}
\end{figure*}



\quad En se référant à la figure 1, on constate que le temps pris pour écrire un fichier d'une taille fixe par \textit{lseek}+\textit{write} décroît quand le buffer augmente jusqu'à se stabiliser à partir d'une certaine taille de buffer. On observe de plus que l'appel à writev est en moyenne plus rapide pour écrire que \textit{write}+\textit{lseek}. Ceci est d'autant plus visible que le buffer est petit (entre 100 et 1000 bytes). Cela s'explique par le fait que plus le buffer est petit plus grand le nombre d'appels systèmes se font. Comme \textit{lseek}+\textit{write} fait appel à 2 appels systèmes que sont \textit{write} et \textit{lseek}, plus on fait appels à eux plus il est normal qu'ils prennent plus de temps même si au final ils écrivent la même quantité d'informations. Une dernière observation est le fait que \textit{writev} garde un temps constant quelque soit le buffer. \\

\quad En conclusion, il est plus intéressant d'utiliser \textit{writev} que \textit{lseek}+\textit{write}. L'appel système \textit{writev} est plus rapide en moyenne que \textit{lseek}+\textit{write} et a l'avantage de garder un temps constant pour une même taille de fichier.


\subsection{readdir}

\begin{figure*}
	\includegraphics[scale = 0.28]{readdir2.png}
	\includegraphics[scale = 0.28]{readdir3.png}
	\label{Graphe du temps mis par l'appel systeme readdir sur un repertoire en fonction du nombre de fichier dans ce repertoire}
	\caption{Graphe du temps mis par l'appel systeme readdir sur un repertoire en fonction du nombre de fichier dans ce repertoire}
\end{figure*}
	
	


\quad Pour la représentation graphique de ce benchmark, nous avons choisis des échelles linéaires.
En se référant aux différentes figures générées, on constate que le temps mis pour parcourir complètement un répertoire est linéaire et proportionnel au nombre de fichiers contenus dans se ce répertoire. Quelques lectures de répertoire prennent légèrement plus de temps que d'autres. Cela est probablement dû au fait que le processus est mis en attente lorsqu'un autre processus fait des lectures.

\section{Difficultés rencontrées}

\quad Une difficulté rencontrée fut de savoir quels fichiers modifier pour prendre en compte nos benchmarks. En effet, nous avons du chercher à plusieurs endroits pour savoir quels fichiers ou lignes ajouter pour que le projet prenne bien en compte nos modifications (creation du make automatique pour nos projets).\\

\quad Une autre difficulté fut de savoir quels critères choisir pour son benchmark et notamment faire un choix entre temps moyen et temps total. En effet, les résultats du benchmark peuvent se voir changer et on peut en arriver à d'autres conclusions. C'est ce qui nous est arrivé avec notre \textit{benchmark} pour lseek+write.\\

\quad A la génération des fichiers dans le benchmark de readdir, nous avons eu quelques difficultés liées au fait que nous ne rendions pas compte qu'il fallait ouvrir et fermer le répertoire à chaque appel du benchmark pour que la lecture se fasse effectivement depuis le début du répertoire.

\quad Lors de notre projet, nous avons inclut le projet initial (benchmark) dans un répertoire git que nous avons crée sur github (https://github.com/edd19/SystInfo\_Projet3). Ca a eut pour conséquence que l'historique des précédents commits a été écrasée. Le seul moyen qu'on a trouvé dès lors pour faire le patch a été de mettre les fichiers crées et modifiés le dossier initial (benchmark) et de patcher ce dernier. Donc pour voir les différents commits que nous avons faits durant le projet vous pouvez visiter le lien suivant : https://github.com/edd19/SystInfo\_Projet3.

\end{multicols}

\clearpage

\end{document}
